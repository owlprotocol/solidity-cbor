"use strict";(self.webpackChunksolidity_cbor_docs=self.webpackChunksolidity_cbor_docs||[]).push([[971],{7522:(e,t,r)=>{r.d(t,{Zo:()=>p,kt:()=>m});var o=r(9901);function n(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function a(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,o)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?a(Object(r),!0).forEach((function(t){n(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,o,n=function(e,t){if(null==e)return{};var r,o,n={},a=Object.keys(e);for(o=0;o<a.length;o++)r=a[o],t.indexOf(r)>=0||(n[r]=e[r]);return n}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)r=a[o],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(n[r]=e[r])}return n}var l=o.createContext({}),c=function(e){var t=o.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},p=function(e){var t=c(e.components);return o.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},u=o.forwardRef((function(e,t){var r=e.components,n=e.mdxType,a=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),u=c(r),m=n,f=u["".concat(l,".").concat(m)]||u[m]||d[m]||a;return r?o.createElement(f,i(i({ref:t},p),{},{components:r})):o.createElement(f,i({ref:t},p))}));function m(e,t){var r=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var a=r.length,i=new Array(a);i[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:n,i[1]=s;for(var c=2;c<a;c++)i[c]=r[c];return o.createElement.apply(null,i)}return o.createElement.apply(null,r)}u.displayName="MDXCreateElement"},4909:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>p,contentTitle:()=>l,default:()=>m,frontMatter:()=>s,metadata:()=>c,toc:()=>d});var o=r(1911),n=r(2633),a=(r(9901),r(7522)),i=["components"],s={sidebar_position:1,slug:"/"},l="Welcome",c={unversionedId:"index",id:"index",title:"Welcome",description:"NPM Package Version",source:"@site/docs/index.md",sourceDirName:".",slug:"/",permalink:"/solidity-cbor/docs/",editUrl:"https://github.com/owlprotocol/solidity-cbor/docs/index.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1,slug:"/"},sidebar:"tutorialSidebar",next:{title:"Quickstart",permalink:"/solidity-cbor/docs/quickstart"}},p={},d=[{value:"How do I encode data into CBOR?",id:"how-do-i-encode-data-into-cbor",level:2},{value:"What&#39;s it for?",id:"whats-it-for",level:2}],u={toc:d};function m(e){var t=e.components,r=(0,n.Z)(e,i);return(0,a.kt)("wrapper",(0,o.Z)({},u,r,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"welcome"},"Welcome"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://npmjs.org/package/@owlprotocol/web3-redux"},(0,a.kt)("img",{parentName:"a",src:"https://img.shields.io/npm/v/@owlprotocol/web3-redux.svg",alt:"NPM Package Version"})),"\n",(0,a.kt)("a",{parentName:"p",href:"https://npmjs.org/package/@owlprotocol/web3-redux"},(0,a.kt)("img",{parentName:"a",src:"https://img.shields.io/npm/dm/@owlprotocol/web3-redux.svg",alt:"NPM Package Downloads"}))),(0,a.kt)("p",null,'A Solidity library designed to allow for decoding complex data structures in Solidity. Think "JSON Parser" but leveraging the Compact Binary Object Representation (CBOR) for more efficiency.'),(0,a.kt)("p",null,"This library allows for decoding and parsing of CBOR-encoded data."),(0,a.kt)("p",null,"CBOR is self-describing, meaning that any CBOR-encoded data passed in can be parsed. There's an\nadditional helper contract ",(0,a.kt)("inlineCode",{parentName:"p"},"ByteParser")," that performs type casting on decoded CBOR values so they\ncan be used within your application logic."),(0,a.kt)("h2",{id:"how-do-i-encode-data-into-cbor"},"How do I encode data into CBOR?"),(0,a.kt)("p",null,"Lucky for you, there's already librarys dedicated to this! Have a look at\n",(0,a.kt)("a",{parentName:"p",href:"https://cbor.io/impls.html"},"this page")," for a quick overview."),(0,a.kt)("p",null,"For example, with NodeJS:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"> const cbor = require('cbor');\n> const myData = {a: '1', b: '2', c: [3,4,5]};\n> cbor.encode(myData).toString('hex');\n// Your CBOR-encoded data:\n'a36161613161626132616383030405'\n")),(0,a.kt)("h2",{id:"whats-it-for"},"What's it for?"),(0,a.kt)("p",null,"Suppose you have some player data you want to use for an in-game NFT:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{\n    name: "Alice",\n    wallet: "0x00000000000000000000000000000001",\n    score: 10,\n    alive: true\n}\n')),(0,a.kt)("p",null,"To keep players honest and unable to forge high scores, we'll use a hash of the data entry\nto verify it's authoritative (i.e. with a MerkleTree, like how ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/Uniswap/merkle-distributor"},"Uniswap performs airdrops"),")."),(0,a.kt)("p",null,"Once the entire record has been verified as authoritative, it's possible to parse out specific fields:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-C++"},'/**\n * Assert record.wallet === msg.sender:\n */\n\n// Extract the `wallet` field from CBOR\nbytes memory walletBytes = CBORDecoding.decodeMappingGetValue(proof, "wallet");\n// Type cast the bytes to an address\naddress walletAddress = ByteUtils.parseAddr(walletBytes);\n// Verify the caller is the record owner\nrequire(msg.sender == walletAddress);\n\n/**\n * Assert record.score > highScore:\n */\n\n// Extract the `score` field from CBOR\nbytes memory scoreBytes = CBORDecoding.decodeMappingGetValue(proof, "score");\n// Type cast the bytes to a uint256\nuint256 score = ByteUtils.bytesToUint256(scoreBytes);\n// Verify the score submitted is higher\nrequire(score > HIGH_SCORE);\n')),(0,a.kt)("p",null,"See ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/owlprotocol/react-snake-game/blob/develop/solidity/contracts/SnakeGameRewards.sol"},"this contract")," for a real contract example."))}m.isMDXComponent=!0}}]);